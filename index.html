<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office">

<head>
<meta http-equiv="Content-Language" content="en-us" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Welcome to BLTsville</title>
<style type="text/css">
.cmd_line {
				background: #000;
				color: #fff;
				padding: 10px;
}
.code_block {
				margin-left: 40px;
				font-family: "Courier New", Courier, monospace;
				font-size: small;
}
.indent1 {
				margin-left: 40px;
}
.center {
}
.Header1 {
				margin: 0px 0 0 0;
				font-size: xx-large;
				font-weight: bold;
				text-align: left;
				line-height: normal;
				background-color: #E0E0E0;
}
.inline_code {
				font-family: "Courier New", Courier, monospace;
				font-size: small;
}
.strong_emphasis {
				text-decoration: underline;
				font-weight: bold;
}
.filename {
				font-family: Arial, Helvetica, sans-serif;
				font-size: small;
}
.small_code_block_in_table {
				font-family: "Courier New", Courier, monospace;
				font-size: x-small;
}
.small_code_block {
				font-family: "Courier New", Courier, monospace;
				font-size: x-small;
				margin-left: 40px;
}
.underline {
				text-decoration: underline;
}
.underline_code {
				font-family: "Courier New", Courier, monospace;
				font-size: small;
				text-decoration: underline;
}
.Code_Header {
				font-size: xx-large;
				font-weight: bold;
				text-align: left;
				font-family: "Courier New", Courier, monospace;
}
.Code_Header_2 {
				font-size: x-large;
				font-weight: bold;
				text-align: left;
				font-family: "Courier New", Courier, monospace;
}
.Code_Header_3 {
				font-size: large;
				font-weight: bold;
				text-align: left;
				font-family: "Courier New", Courier, monospace;
}
.grn_left {
				text-align: left;
				color: #009900;
}
.left_topbord {
				text-align: left;
				border-top-style: solid;
				border-top-width: 1px;
}
.center_topbord {
				text-align: center;
				border-top-style: solid;
				border-top-width: 1px;
}
.blue_left_botbord {
				text-align: left;
				border-bottom-style: solid;
				border-bottom-width: 1px;
				color: #0000FF;
}
.blue_ctr_botbord {
				text-align: center;
				border-bottom-style: solid;
				border-bottom-width: 1px;
				color: #0000FF;
}
.red_ctr {
				text-align: center;
				color: #FF0000;
}
.red_left {
				text-align: left;
				color: #FF0000;
}
.grn_ctr {
				text-align: center;
				color: #009900;
}
.red_ctr_topbord {
				text-align: center;
				border-top-style: solid;
				border-top-width: 1px;
				color: #FF0000;
}
.blu_ctr_topbord {
				text-align: center;
				border-top-style: solid;
				border-top-width: 1px;
				color: #0000FF;
}
.indent_thick_bord {
				border-color: #000000;
				border-style: solid;
				margin-left: 40px;
}
.thin_bord {
				border: 1px solid #000000;
}
.thin_bord_dbl_botbord {
				border-color: #000000;
				border-left-style: solid;
				border-left-width: 1px;
				border-right-style: solid;
				border-right-width: 1px;
				border-top-style: solid;
				border-top-width: 1px;
				border-bottom-style: double;
				border-bottom-width: 3px;
}
.dl_link {
				float: right;
}
.small_note {
				font-size: xx-small;
				line-height: 100%;
}
.Header2 {
				font-size: xx-large;
				font-weight: bold;
				margin: 0px;
				line-height: 100%;
}
.ctr {
				text-align: center;
}
</style>
</head>

<body>

<table style="width: 100%; line-height: 100%;">
				<tr>
								<td style="width: 484px">
<img alt="" src="bvlogo.png"/></td>
								<td>
								<p>BLTsville is the open 2-D API designed to provide an abstract interface for both 
								hardware and software 2-D implementations.</p>
<p>BLTs (BLock Transfers) involve the moving around of blocks (rectangles) of pixels.&nbsp; BLTsville is the place to go 
for BLTs.</p>
<hr />
												<table style="width: 100%">
																<tr>
																				<td>
<div class="dl_link"><img alt="CC BY-ND" longdesc="Creative Commons Attribution-NoDerivs 3.0 Unported License" src="http://i.creativecommons.org/l/by-nd/3.0/88x31.png" width="88" height="31" /></div>
<p class="Header2">License</p>
																</td>
																</tr>
																<tr>
																				<td>
<div>
<p class="small_note">The API is designed and maintained by Texas Instruments, Inc., but anyone is free to use it with no 
cost or obligation.</p>
<p>This project is licensed under the <a href="http://creativecommons.org/licenses/by-nd/3.0/">Creative Commons 
Attribution-NoDerivs 3.0 Unported License</a>.</p>
</div>
																				</td>
																</tr>
												</table>
<hr />
								<table style="width: 100%">
												<tr>
																<td>
<p class="Header2">Dependencies</p>
																</td>
																</tr>
																<tr>
																				<td>
<p>This project is dependent on the <a href="http://graphics.github.com/ocd">Open Color format Defintions (OCD) project</a>.</p>
																</td>
																</tr>
												</table>
<hr />
    							<table style="width: 100%">
												<tr>
																<td>
    <p class="Header2">Source</p>
    															</td>
												</tr>
												<tr>
																<td>
    <div class="dl_link">
      <a href="http://github.com/graphics/bltsville/zipball/master">
        <img width="90" alt="download zip" src="http://github.com/images/modules/download/zip.png"/></a>
      <a href="http://github.com/graphics/bltsville/tarball/master">
        <img width="90" alt ="download tar" src="http://github.com/images/modules/download/tar.png"/></a>
    </div>
<div>
      Get the source code on GitHub at <a href="http://github.com/graphics/bltsville">graphics/bltsville</a>, or download this project in either
      <a href="http://github.com/graphics/bltsville/zipball/master">zip</a> or
      <a href="http://github.com/graphics/bltsville/tarball/master">tar</a> formats.</div>
    <p>You can also clone the project with <a href="http://git-scm.com">Git</a> by running:</p>
      <pre><a class="cmd_line">$ git clone git://github.com/graphics/bltsville</a></pre>
																</td>
												</tr>
								</table>
								</td>
				</tr>
</table>
<hr />
<p class="Header1">Points of Interest in BLTsville</p>
<table style="width: 100%">
				<tr>
								<td style="width: 50%" valign="top">
<ul>
				<li>Solid fills</li>
				<li>Pattern fills</li>
				<li>Copies</li>
				<li>Color format conversion<ul>
								<li>Extensive color format support<ul>
												<li>RGB, BGR</li>
												<li>RGBA, ARGB, etc.</li>
												<li>YCbCr (YUV)<ul>
																<li>subsampling</li>
																<li>packed</li>
																<li>planar</li>
												</ul>
												</li>
												<li>Monochrome</li>
												<li>Alpha-only</li>
												<li>Look-Up Table (LUT)</li>
								</ul>
								</li>
								<li>Extensible color format</li>
				</ul>
				</li>
				<li>ROP4<ul>
								<li>Three inputs</li>
				</ul>
				</li>
				<li>Blends<ul>
								<li>Pre-defined Porter-Duff blends</li>
								<li>Pre-defined DirectFB support</li>
								<li>Extensible blends</li>
				</ul>
				</li>
				<li>Multiple </li>
				<li>Filters<ul>
								<li>Extensible filters</li>
				</ul>
				</li>
				<li>Independent horizontal and vertical <strong>flipping</strong></li>
				<li>Independent <strong>scaling</strong> of all three inputs</li>
				<li>Clipping</li>
				<li>Independent <strong>rotation</strong> of all three inputs 
				(multiples of 90 degrees)</li>
</ul>
								</td>
								<td style="width: 50%" valign="top">
<ul>
				<li>Choice of <strong>scaling</strong> type<ul>
								<li>Quality based choice</li>
								<li>Speed based choice</li>
								<li>Image type based choice</li>
								<li>Specific scale type choice</li>
								<li>Extensible scale type</li>
				</ul>
				</li>
				<li>Synchronous operations</li>
				<li>Asynchronous operations<ul>
								<li>Client notification of BLT completion</li>
				</ul>
				</li>
				<li>Batching<ul>
								<li>Combine multiple BLTs into group that can be 
								handled more efficiently by implementations<ul>
												<li>Character BLTs</li>
												<li>Multi-layer blending</li>
												<li>ROP/Blend combination with 
												specified ordering</li>
												<li>etc.</li>
								</ul>
								</li>
								<li>Delta BLTs</li>
				</ul>
				</li>
				<li>Dithering<ul>
								<li>Quality based choice</li>
								<li>Speed based choice</li>
								<li>Image type based choice</li>
								<li>Specific dither type choice</li>
								<li>Extensible dither type</li>
				</ul>
				</li>
				<li>Any implementation support<ul>
								<li>CPU</li>
								<li>2-D Accelerator</li>
				</ul>
				</li>
</ul>
								</td>
				</tr>
</table>
<ul>
				<li>BLTsville does not dictate capabilities of the 
				implementations<ul>
								<li>Operation specified either works or returns 
								a response indicating it&#39;s not supported</li>
				</ul>
				</li>
</ul>
<hr />
<p class="Header1">How to Get to BLTsville</p>
<p>BLTsville&#39;s API is defined in the BLTsville header files.&nbsp; A client must 
include <span class="inline_code">bltsville.h</span> to access the 
implementations.</p>
<p><em>Note that the </em> <span class="underline_code"><em>bvinternal.h</em></span><em><span class="underline"> header is for 
implementations only</span> and should not be used by clients.</em></p>
<p class="indent1">BLTsville currently has a user mode interface, but kernel 
mode is on the way.&nbsp; 
<em>Obviously, the kernel mode interface will have more operating system 
dependence, but as much as possible, the user mode itself is agnostic of 
operating system.&nbsp; However, the kernel mode interface will be quite similar 
to the user mode.</em></p>
<hr />
<p class="Header1">BLTsville Neighborhoods</p>
<p>For most BLTsville clients, only one or both of the two main implementations 
will be used.&nbsp; These two implementations are the CPU and default 2-D hardware 
implementations.&nbsp; Clients use the standard names below to access these 
implementations.&nbsp; The specific 
name decoration will be dictated by the host Operating System (O/S):</p>
<ul>
				<li>CPU:&nbsp; <span class="filename">bltsville_cpu</span><ul>
								<li>Linux/Android:&nbsp; <span class="filename">libbltsville_cpu.so</span></li>
								<li>Windows:&nbsp; <span class="filename">bltsville_cpu.dll</span></li>
								<li>etc.</li>
				</ul>
				</li>
				<li>2-D hardware:&nbsp; <span class="filename">bltsville_2d</span><ul>
								<li>Linux/Android:&nbsp; <span class="filename">libbltsville_2d.so</span></li>
								<li>Windows:&nbsp; <span class="filename">bltsville_2d.dll</span></li>
								<li>etc.</li>
				</ul>
				</li>
</ul>
<p>These entry points may represent the implementations themselves, or they may 
be symbolic links.&nbsp; In most cases, system integration will will connect the 
client 
with the most capable 2-D hardware available in the system.&nbsp; For example,
<span class="filename">bltsville_2d</span> might be a symbolic link to
<span class="filename">bltsville_vivante2d</span>.</p>
<p>In addition, there may be more implementations co-existing in a given system.&nbsp; 
These will have 
additional unique names as determined by the vendors.&nbsp; For example:</p>
<ul>
				<li>Reference CPU implementation:&nbsp; <span class="filename">bltsville_refcpu</span></li>
				<li>System DMA:&nbsp; <span class="filename">bltsville_mydma</span></li>
</ul>
<hr />
<p class="Header1">Visiting BLTsville</p>
<p>More than one BLTsville implementation may be available.&nbsp; To facilitate this, BLTsville 
implementation libraries are dynamically loaded by the client.&nbsp; Then the 
BLTsville 
entry points are imported.&nbsp; The specific procedure for this is dictated by the host 
O/S.</p>
<hr />
<p class="Header1">Things To Do In BLTsville</p>
<p>BLTsville&#39;s interface consists of three functions per implementation, 
which must be imported by the client at run time:</p>
<ul class="code_block">
				<li><span class="inline_code"><a href="#bv_map">bv_map()</a></span></li>
				<li><span class="inline_code"><a href="#bv_blt">bv_blt()</a></span></li>
				<li><span class="inline_code"><a href="#bv_unmap">bv_unmap()</a></span></li>
</ul>
<a name="bv_map" class="Code_Header">bv_map()</a>
<p class="code_block">enum bverror bv_map(struct bvbuffdesc* buffdesc);</p>
<p><span class="strong_emphasis">BLTsville does not allocate buffers.</span>&nbsp;&nbsp; 
Clients must provide a buffer description via the <span class="inline_code">
<a href="#bvbuffdesc">bvbuffdesc</a></span> structure so that BLTsville can 
access the buffer.</p>
<p><span class="inline_code">bv_map()</span> is used to provide the 
implementation an opportunity to associate hardware 
resources with the specified buffer.&nbsp; Most hardware requires this type of 
mapping, and there is usually appreciable overhead associated with it.</p>
<p>Client are provided with <span class="inline_code">bv_map()</span> so they can control exactly when the 
mapping overhead is encountered.&nbsp;&nbsp; For a given buffer, the client can 
call the <span class="inline_code">bv_map()</span> in each implementation to establish that mapping immediately.</p>
<p>As a special bonus, BLTsville clients are not required to call
<span class="inline_code">bv_map()</span> for each implementation being used.&nbsp; 
One call to any implementation&#39;s <span class="inline_code">bv_map()</span> is 
sufficient to indicate that the client can be trusted to make the corresponding 
call to <span class="inline_code"><a href="#bv_unmap">bv_unmap()</a></span> upon 
destruction of the buffer.&nbsp; As a result, the implementations can use
<em>lazy mapping</em> only as necessary.&nbsp; This way a client that 
has multiple implementations available will not incur the overhead of the 
mapping at all, unless a <span class="inline_code"><a href="#bv_blt">bv_blt()</a></span> 
call to that implementation is made.&nbsp; But the mapping is maintained, so that the overhead 
is avoided on subsequent <span class="inline_code"><a href="#bv_blt">bv_blt()</a></span> 
calls.</p>
<p><em><strong>Calling </strong></em> <span class="inline_code">
<em><strong>bv_map()</strong></em></span><em><strong> is actually optional prior to calling
</strong></em>
<span class="inline_code"><a href="#bv_blt"><em><strong>bv_blt()</strong></em></a></span><em><strong>.&nbsp; However, if
it is not called at least once for a 
given buffer, the necessary mapping must be done automatically when
</strong></em>
<span class="inline_code"><a href="#bv_blt"><em><strong>bv_blt()</strong></em></a></span><em><strong> is called, and 
unmapping must be done when it is complete.&nbsp; This means the overhead will be incurred for every 
</strong></em> 
<a href="#bv_blt" class="inline_code"><em><strong>bv_blt()</strong></em></a><em><strong> call which uses that buffer.</strong></em></p>
<p><em>Normally, the lowest overhead </em><span class="inline_code"><em>bv_map()</em></span><em> 
call will be in the CPU-based implementation.&nbsp; So most clients will want to 
make a single, low overhead </em><span class="inline_code"><em>bv_map()</em></span><em> 
call to the bltsville_cpu implementation to avoid the mapping/unmapping 
overhead on each </em><span class="inline_code"><a href="#bv_blt"><em>bv_blt()</em></a></span><em> 
call, while avoiding the mapping overhead when possible.</em></p>
<p><em>NOTE: Obviously any API cannot add capabilities beyond an implementation&#39;s 
capabilities.&nbsp; So if the 
implementation requires memory to be allocated from a special pool, that 
responsibility falls upon the client.&nbsp; The </em> <span class="coderef"><em>bv_map()</em></span><em> 
function for that implementation will need to check the characteristics of the 
memory and return an error if it does not meet the necessary criteria.</em></p>
<a name="bv_blt" class="Code_Header">bv_blt()</a>
<p class="code_block">enum bverror bv_blt(struct bvbltparams* bltparams);</p>
<p>The main function of BLTsville is <span class="inline_code">bv_blt()</span>.&nbsp; 
A <span class="inline_code"><a href="#bvbltparams">bvbltparams</a></span> structure is passed into
<span class="inline_code">bv_blt()</span> to trigger the desired 2-D operation.</p>
<a name="bv_unmap" class="Code_Header">bv_unmap()</a>
<p class="code_block">enum bverror bv_unmap(struct bvbuffdesc* buffdesc);</p>
<p><span class="inline_code">bv_unmap()</span> is used to free implementation 
resources associated with a buffer.&nbsp; If <span class="inline_code">
<a href="#bv_map">bv_map()</a></span> was called for a given buffer,
<span class="inline_code">bv_unmap()</span> must be called as well.</p>
<p>For convenience, only one <span class="inline_code">bv_unmap()</span> needs 
to be called for each buffer, regardless of how many implementations were used, 
including multiple calls to <span class="inline_code"><a href="#bv_map">bv_map()</a></span>.</p>
<p>Also for convenience, <span class="inline_code">bv_unmap()</span> may be 
called multiple times on the same buffer.&nbsp; Note that only the first call 
will actually free (all) associated resources.&nbsp;</p>
<a name="bvbltparams" class="Code_Header">bvbltparams</a>
<p><span class="inline_code">bvbltparams</span> is the central structure in 
BLTsville.&nbsp; This structure holds the details of the BLT being requested by 
the client.</p>
<p class="small_code_block">struct bvbltparams {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int <a href="#bvbltparams.structsize">structsize</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *<a href="#errdesc">errdesc</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long <a href="#implementation">implementation</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long <a href="#flags">flags</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
unsigned short <a href="#rop">rop</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
enum bvblend <a href="#blend">blend</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
struct bvfilter *<a href="#filter">filter</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <a href="#op">op</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *<a href="#colorkey">colorkey</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union bvalpha <a href="#globalalpha">globalalpha</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enum bvscalemode <a href="#scalemode">scalemode</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enum bvdithermode <a href="#dithermode">dithermode</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct bvbuffdesc *<a href="#dstdesc">dstdesc</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct bvsurfgeom *<a href="#dstgeom">dstgeom</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct bvrect <a href="#dstrect">dstrect</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
struct bvbuffdesc *<a href="#src1.desc">desc</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
struct bvtileparams *<a href="#src1.tileparams">tileparams</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <a href="#src1">src1</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct bvsurfgeom *<a href="#src1geom">src1geom</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct bvrect <a href="#src1rect">src1rect</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
struct bvbuffdesc *<a href="#src2.desc">desc</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
struct bvtileparams *<a href="#src2.tileparams">tileparams</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <a href="#src2">src2</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct bvsurfgeom *<a href="#src2geom">src2geom</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct bvrect <a href="#src2rect">src2rect</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
struct bvbuffdesc *<a href="#mask.desc">desc</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
struct bvtileparams *<a href="#mask.tileparams">tileparams</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <a href="#mask">mask</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct bvsurfgeom *<a href="#maskgeom">maskgeom</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct bvrect <a href="#maskrect">maskrect</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct bvrect <a href="#cliprect">cliprect</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long <a href="#batchflags">batchflags</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct bvbatch *<a href="#batch">batch</a>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void (*<a href="#callbackfn">callbackfn</a>)(struct 
bvcallbackerror* err,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
unsigned long handle);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long <a href="#callbackdata">callbackdata</a>;<br />
};&nbsp;</p>
<a name="bvbltparams.structsize" class="Code_Header_2">bvbltparams.structsize</a>
<p><span class="code_block">unsigned long structsize; /* input 
*/</span></p>
<p>BLTsville is designed to be forwards and backwards compatible between client 
and library versions.&nbsp; But this compatibility would be eliminated if 
clients chose to check for a specific version of the BLTsville implementations 
and fail if the specific version requested was not in place.</p>
<p>Instead, BLTsville structures use the <span class="inline_code">structsize</span> 
member to indicate the number of bytes in the structure, which is used to 
communicate between the client and implementation which portions of the 
structure are current.&nbsp; This effectively bypasses the concept of a version 
and focuses on the specifics of what changes need to be considered to maintain 
compatibility.</p>
<ol>
				<li>When an old client calls into a new implementation, that 
				implementation will realize if the client only provides a subset 
				of an updated structure.&nbsp; The implementation will handle 
				this and utilize only that information which has been provided.&nbsp; 
				New features will be disabled, but functionality will be 
				maintained.</li>
				<li>When a new client calls into an old implementation, that 
				implementation will ignore the extra members of the structure 
				and operate in ignorance of them.&nbsp; If these members are 
				necessary for some new functionality, this will be evident from 
				other fields in the structure, so that the implementation can 
				gracefully fail.</li>
</ol>
<p>If <span class="inline_code">structsize</span>&nbsp;is set to a value that is too 
small for an implementation, it may return a <span class="inline_code">
<a href="#BVERR_BLTPARAMS_VERS">BVERR_BLTPARAMS_VERS</a></span> error.</p>
<p class="Code_Header_2"><a name="bvbltparams.errdesc">bvbltparams.errdesc</a></p>
<p><span class="code_block">char* errdesc; /* output */</span></p>
<p><span class="inline_code">errdesc</span> is optionally used by 
implementations to pass a 0-terminated string with additional&nbsp;debugging 
information back to clients for debugging purposes.&nbsp;
<span class="inline_code">errdesc</span> is not localized or otherwise meant to 
provide information that is displayed to users.</p>
<p class="Code_Header_2"><a name="bvbltparams.implementation">bvbltparams.implementation</a></p>
<p class="code_block">unsigned long implementation;&nbsp;/* input */</p>
<p>Multiple implementations of BLTsville can be combined under managers which 
can distribute the BLT requests to the implementations based on whatever 
criteria the manager chooses.&nbsp; This might include availability of the 
operation, performance, loading, or power state.&nbsp; In such a scenario, the 
client may need to override or augment the choice made by the manager.&nbsp; 
This field allows that control.</p>
<p><strong><em>Note that this feature is extremely complicated, and more 
detailed documentation needs to be created to allow creation of managers and 
smooth integration by a client.&nbsp; There are serious issues that must be 
understood before any manager can be put into place, such as CPU cache coherence 
and multiple implementation operation interdependence.&nbsp; For now, this field 
should be set to 0 by clients.</em></strong></p>
<p>If the implementation cannot respond to the <span class="inline_code">
implementation</span> flags set, it may return a <span class="inline_code">
<a href="#BVERR_IMPLEMENTATION">BVERR_IMPLEMENTATION</a></span> error.</p>
<p class="Code_Header_2"><a name="flags">bvbltparams.flags</a></p>
<p class="code_block">unsigned long flags; /* input */</p>
<p>The <span class="inline_code">flags</span> member provides the baseline of 
information to <span class="inline_code"><a href="#bv_blt">bv_blt()</a></span> 
about the type of BLT being requested.</p>
<p>To maintain compatibility, unused bits in the flags member should be set to 
0.</p>
<p>If the flags set are not supported by the implementation, it may return
<span class="inline_code"><a href="#BVERR_FLAGS">BVERR_FLAGS</a></span>, or a 
more specific <a href="#bverror">error code</a>.</p>
<p class="Code_Header_3"><a name="BVFLAG_OP_">bvbltparams.flags - BVFLAG_OP_*</a></p>
<p>The <span class="inline_code">op</span> field of the flags member specifies 
the type of BLT operation to perform.&nbsp; Currently there are three types of 
BLT operations defined:</p>
<table style="width: 100%">
				<tr>
								<td valign="top">1.</td>
								<td><span class="inline_code"><strong><a name="BVFLAG_ROP">BVFLAG_ROP</a></strong></span><br />
								<p>This flag indicates the operation being performed is a raster operation, and the
								<span class="inline_code"><a href="#op">bvbltparams.op</a></span> union is treated as
								<span class="inline_code"><a href="#rop">rop</a></span>.&nbsp; Raster OPerations are 
								binary operations performed on the bits of the inputs.&nbsp; See
								<span class="inline_code"><a href="#rop">bvbltparams.op.rop</a></span> for details.<br />
								</p>
								<br />
								</td>
				</tr>
				<tr>
								<td valign="top">2.</td>
								<td>
								<p><span class="inline_code"><strong><a name="BVFLAG_BLEND">BVFLAG_BLEND</a></strong></span><br />
								</p>
								<p>This flag indicates the operation being performed is a blend, and the
								<span class="inline_code"><a href="#op">bvbltparams.op</a></span> union is treated as
								<span class="inline_code"><a href="#blend">blend</a></span>.&nbsp;
								Blending involves mixing multiple layers of 
								pixels using the specified equations.&nbsp; 
								Surrounding pixels are not involved in blend 
								operations.&nbsp; See <span class="inline_code"><a href="#blend">bvbltparams.op.blend</a></span> 
								for details.</p>
								<p>&nbsp;</p>
								</td>
				</tr>
				<tr>
								<td valign="top">3.</td>
								<td><span class="inline_code"><strong><a name="BVFLAG_FILTER">BVFLAG_FILTER</a></strong></span><br />
								<br />
								This flag indicates the operation being performed is a filter, and the
								<span class="inline_code"><a href="#op">bvbltparams.op</a></span> union is treated as
								<span class="inline_code"><a href="#filter">filter</a></span>.&nbsp;
								Filtering involves mixing multiple layers of 
								pixels.&nbsp; Surrounding pixels are involved in filter 
								operations.&nbsp; See <span class="inline_code"><a href="#filter">bvbltparams.op.filter</a></span> 
								for details.<br />
								</td>
				</tr>
</table>
<p class="Code_Header_3"><a name="BVFLAG_KEY_SRC">bvbltparams.flags - BVFLAG_KEY_SRC</a>/<a name="BVFLAG_KEY_DST">DST</a></p>
<p>The <span class="inline_code">BVFLAG_KEY_SRC</span> and <span class="inline_code">BVFLAG_KEY_DST</span> enable source 
and destination color keying, respectively.&nbsp; When either flag is set, the <span class="inline_code"><a href="#colorkey">colorkey</a></span> 
member of <span class="inline_code"><a href="#bvbltparams">bvbltparams</a></span> is used.</p>
<p><span class="inline_code">BVFLAG_KEY_SRC</span> and <span class="inline_code">BVFLAG_KEY_DST</span> are mutually 
exclusive.</p>
<p>See <span class="inline_code"><a href="#colorkey">bvbltparams.colorkey</a></span> for details.</p>
<p class="Code_Header_3"><a name="BVFLAG_CLIP">bvbltparams.flags - BVFLAG_CLIP</a></p>
<p>When <span class="inline_code">BVFLAG_CLIP</span> is set, the <span class="inline_code"><a href="#cliprect">cliprect</a></span> 
member of <span class="inline_code"><a href="#bvbltparams">bvbltparams</a></span> is used by the implementation as a 
limiting rectangle on data written to the destination.&nbsp; This is most useful for scaling operations, where the 
necessary scaling factor will not allow translation of the destination rectangle back to the source on an integer pixel 
boundary.</p>
<p>For example, if the goal is to show a 640 x 480 video on a 1920 x 1080 screen, the video would be stretched to 1440 x 
1080 to maintain the proper aspect ratio.&nbsp; So the relevant rectangles would be:</p>
<table class="indent1">
				<tr>
								<td class="thin_bord"><strong>src1rect</strong></td>
								<td class="thin_bord"><strong>dstrect</strong></td>
				</tr>
				<tr>
								<td class="thin_bord">(0, 0) - 640 x 480</td>
								<td class="thin_bord">(240, 0) - 1440 x 1080</td>
				</tr>
</table>
<p>However, to handle a 640 x 480 pop-up window that appears centered on the screen, in front of the video, the single 
BLT may be broken into four smaller BLTs pieced around the popup.&nbsp; These rectangles would need to be:</p>
<table class="indent1">
				<tr>
								<td class="thin_bord"><strong>src1rect</strong></td>
								<td class="thin_bord"><strong>dstrect</strong></td>
				</tr>
				<tr>
								<td class="thin_bord">(0, 0) - 640 x 133.333...</td>
								<td class="thin_bord">(240, 0) - 1440 x 300</td>
				</tr>
				<tr>
								<td class="thin_bord">(0, 133.333...) - 284.444... x 213.333...</td>
								<td class="thin_bord">(240, 300) - 400 x 480</td>
				</tr>
				<tr>
								<td class="thin_bord">(568.888..., 133.333...) - 284.444... x 213.333...</td>
								<td class="thin_bord">(1280, 300) - 400 x 480</td>
				</tr>
				<tr>
								<td class="thin_bord">(0, 346.666...) - 640 x 133.333...</td>
								<td class="thin_bord">(240, 780) - 1440 x 300</td>
				</tr>
</table>
<p>Since this is a scaling factor of 2.25x, translating the required destination rectangles back to the source results 
in non-integer coordinates and dimensions, as illustrated above.&nbsp; And adjusting the source rectangles to the 
nearest integer values will result in visible discontinuities at the boundaries between the rectangles.</p>
<p>Instead, using the <span class="inline_code">cliprect</span>, this situation can be handled more easily:</p>
<table class="indent1">
				<tr>
								<td class="thin_bord"><strong>src1rect</strong></td>
								<td class="thin_bord"><strong>dstrect</strong></td>
								<td class="thin_bord"><strong>cliprect</strong></td>
				</tr>
				<tr>
								<td class="thin_bord">(0, 0) - 640 x 480</td>
								<td class="thin_bord">(240, 0) - 1440 x 1080</td>
								<td class="thin_bord">(240, 0) - 1440 x 300</td>
				</tr>
				<tr>
								<td class="thin_bord">(0, 0) - 640 x 480</td>
								<td class="thin_bord">(240, 0) - 1440 x 1080</td>
								<td class="thin_bord">(240, 300) - 400 x 480</td>
				</tr>
				<tr>
								<td class="thin_bord">(0, 0) - 640 x 480</td>
								<td class="thin_bord">(240, 0) - 1440 x 1080</td>
								<td class="thin_bord">(1280, 300) - 400 x 480</td>
				</tr>
				<tr>
								<td class="thin_bord">(0, 0) - 640 x 480</td>
								<td class="thin_bord">(240, 0) - 1440 x 1080</td>
								<td class="thin_bord">(240, 780) - 1440 x 300</td>
				</tr>
</table>
<p class="Code_Header_3"><a name="BVFLAG_SRCMASK">bvbltparams.flags - BVFLAG_SRCMASK</a></p>
<p>Normally, the mask is applied at the destination, after all scaling has been completed (including scaling the mask if 
necessary).&nbsp; But some environments require that the mask be applied at the sources, before scaling occurs.&nbsp; 
The <span class="inline_code">BVFLAG_SRCMASK</span> flag requests that the implementation use this method if supported.</p>
<p class="Code_Header_3">bvbltparams.flags - BVFLAG_TILE_*</p>
<p>Normally, when a source&#39;s size does not match the destination, the source is scaled to fill the destination.&nbsp; 
But when the corresponding <span class="inline_code">BVFLAG_TILE_*</span> flag is set, this behavior is modified.</p>
<p>First, the source&#39;s size specifies a tile (or pattern, or brush) to be used to fill the destination.&nbsp; This tile 
is replicated instead of scaled.</p>
<p>The origin of the source&#39;s rectangle is used to locate the tile within a larger surface. </p>
<p>Second, a <span class="inline_code"><a href="#bvbuffdesc">bvbuffdesc</a></span> object is no longer supplied by the 
client in the bvbltparams structure.&nbsp; In its place is a <span class="inline_code"><a href="#bvtileparams">
bvtileparams</a></span> object.</p>
<p>Refer to the <span class="inline_code"><a href="#bvtileparams">bvtileparams</a></span> structure definition for 
details.</p>
<p class="Code_Header_3">bvbltparams.flags - BVFLAG_HORZ/VERT_FLIP_*</p>
<p>These flags indicate that the corresponding image is flipped horizontally or vertically as it is used by the 
operation.</p>
<p class="Code_Header_3">bvbltparams.flags - BVFLAG_SCALE/DITHER_RETURN</p>
<p>The scale and dither types can be specified with an implicit type.&nbsp; The implementation will then convert that 
internally to an explicit scale or dither type.&nbsp; These flags request that the implementation return the explicit 
type chosen to the client in the corresponding <span class="inline_code"><a href="#scalemode">bvbltparams.scalemode</a></span> 
and <span class="inline_code"><a href="#dithermode">bvbltparams.dithermode</a></span> members.</p>
<p class="Code_Header_3">bvbltparams.flags - BVFLAG_ASYNC</p>
<p>This flag allows the client to inform the implementation that it can queue the requested BLT and return from
<span class="inline_code"><a href="#bv_blt">bv_blt()</a></span> before it has completed.&nbsp; If this bit is not set, 
when the <span class="inline_code"><a href="#bv_blt">bv_blt()</a></span> returns, the operation is complete.</p>
<p>Normally, a client will also utilize the <span class="inline_code"><a href="#callbackfn">bvbltparams.callbackfn</a></span> 
and <span class="inline_code"><a href="#callbackdata">bvbltparams.callbackdata</a></span> members to receive a 
notification when the BLT has completed.</p>
<p class="Code_Header_3">bvbltparams.flags - BVFLAG_BATCH_BEGIN/CONTINUE/END</p>
<p>These flags are used to control batching of BLTs for two main reasons:</p>
<ol>
				<li>To group small, similar BLTs to consolidate overhead.&nbsp; For example, the BLTs associated with 
				rendering each character in a word.</li>
				<li>To group related BLTs, which may allow an implementation to perform a more efficient, but equivalent 
				set of operations.</li>
</ol>
<p>See <a href="#batching">Batching</a> for details.</p>
<p class="Code_Header_2"><a name="rop">bvbltparams.op.rop</a></p>
								<p class="code_block">unsigned short rop; /* input */</p>
<p>When <span class="inline_code"><a href="#BVFLAG_ROP">BVFLAG_ROP</a></span> is set in 
								the <span class="inline_code"><a href="#flags">bvbltparams.flags</a></span> member, the
								<span class="inline_code"><a href="#op">bvbltparams.op</a></span> union is treated as
								<span class="inline_code">rop</span>.&nbsp; Raster OPerations are binary operations 
								performed on the bits of the inputs:</p>
<ul>
												<li>ROP1s have one source:&nbsp; 
												the destination.&nbsp; Two bits 
												are sufficient to specify the 
												four possible (2<sup>2</sup>) 
												ROP1 operations.</li>
												<li>ROP2s have two sources:&nbsp; 
												the destination and a source.&nbsp; 
												Four bits are used to specify 
												the sixteen (2<sup>2+2</sup>) 
												ROP2 operations.</li>
												<li>ROP3s have three sources:&nbsp; 
												the destination, a source 
												(source 1), and a pattern 
												(a.k.a. brush), which we call 
												source 2 in BLTsville.&nbsp; 
												Eight bits are used to specify 
												the 256 (2<sup>2+2+2</sup>) ROP3 
												operations.</li>
												<li>ROP4s have four sources:&nbsp; 
												the destination, two sources, 
												and a mask.&nbsp; Sixteen bits 
												are used to specify the 65,536 
												(2<sup>2+2+2+2</sup>) ROP4 
												operations.</li>
								</ul>
								<p>BLTsville&#39;s <span class="inline_code">rop</span> 
								element is used to specify a ROP4, but anything 
								from ROP1 up to ROP4 can be defined using this 
								member:</p>
								<ul>
												<li>To specify an 8-bit ROP3 as a 16-bit ROP4, 
												replicate the 8 bits twice:&nbsp; 
												0x2323.</li>
												<li>To specify a 4-bit ROP2 as a 16-bit ROP4, 
												replicate the 4 bits four times:&nbsp; 
												0x2222.</li>
												<li>To specify a 2-bit ROP1 as a 16-bit ROP4, 
												replicate the 2 bits eight 
												times:&nbsp; 0x5555.</li>
								</ul>
								<p>The table below is the magic decoder ring:&nbsp;</p>
								<table class="indent1">
												<tr>
																<td>
																Mask</td>
																<td class="ctr" style="width: 20px">
																1</td>
																<td class="ctr" style="width: 20px">
																1</td>
																<td class="ctr" style="width: 20px">
																1</td>
																<td class="ctr" style="width: 20px">
																1</td>
																<td class="ctr" style="width: 20px">
																1</td>
																<td class="ctr" style="width: 20px">
																1</td>
																<td class="ctr" style="width: 20px">
																1</td>
																<td class="ctr" style="width: 20px">
																1</td>
																<td class="ctr" style="width: 20px">
																0</td>
																<td class="ctr" style="width: 20px">
																0</td>
																<td class="ctr" style="width: 20px">
																0</td>
																<td class="ctr" style="width: 20px">
																0</td>
																<td class="ctr" style="width: 20px">
																0</td>
																<td class="ctr" style="width: 20px">
																0</td>
																<td class="ctr" style="width: 20px">
																0</td>
																<td class="ctr" style="width: 20px">
																0</td>
												</tr>
												<tr>
																<td class="red_left">
																Source 2&nbsp;</td>
																<td class="red_ctr" style="width: 20px">
																1</td>
																<td class="red_ctr" style="width: 20px">
																1</td>
																<td class="red_ctr" style="width: 20px">
																1</td>
																<td class="red_ctr" style="width: 20px">
																1</td>
																<td class="red_ctr" style="width: 20px">
																0</td>
																<td class="red_ctr" style="width: 20px">
																0</td>
																<td class="red_ctr" style="width: 20px">
																0</td>
																<td class="red_ctr" style="width: 20px">
																0</td>
																<td class="red_ctr" style="width: 20px">
																1</td>
																<td class="red_ctr" style="width: 20px">
																1</td>
																<td class="red_ctr" style="width: 20px">
																1</td>
																<td class="red_ctr" style="width: 20px">
																1</td>
																<td class="red_ctr" style="width: 20px">
																0</td>
																<td class="red_ctr" style="width: 20px">
																0</td>
																<td class="red_ctr" style="width: 20px">
																0</td>
																<td class="red_ctr" style="width: 20px">
																0</td>
												</tr>
												<tr>
																<td class="grn_left">
																Source 1&nbsp;</td>
																<td class="grn_ctr" style="width: 20px">
																1</td>
																<td class="grn_ctr" style="width: 20px">
																1</td>
																<td class="grn_ctr" style="width: 20px">
																0</td>
																<td class="grn_ctr" style="width: 20px">
																0</td>
																<td class="grn_ctr" style="width: 20px">
																1</td>
																<td class="grn_ctr" style="width: 20px">
																1</td>
																<td class="grn_ctr" style="width: 20px">
																0</td>
																<td class="grn_ctr" style="width: 20px">
																0</td>
																<td class="grn_ctr" style="width: 20px">
																1</td>
																<td class="grn_ctr" style="width: 20px">
																1</td>
																<td class="grn_ctr" style="width: 20px">
																0</td>
																<td class="grn_ctr" style="width: 20px">
																0</td>
																<td class="grn_ctr" style="width: 20px">
																1</td>
																<td class="grn_ctr" style="width: 20px">
																1</td>
																<td class="grn_ctr" style="width: 20px">
																0</td>
																<td class="grn_ctr" style="width: 20px">
																0</td>
												</tr>
												<tr>
																<td class="blue_left_botbord">
																Destination&nbsp;</td>
																<td class="blue_ctr_botbord" style="width: 20px">
																1</td>
																<td class="blue_ctr_botbord" style="width: 20px">
																0</td>
																<td class="blue_ctr_botbord" style="width: 20px">
																1</td>
																<td class="blue_ctr_botbord" style="width: 20px">
																0</td>
																<td class="blue_ctr_botbord" style="width: 20px">
																1</td>
																<td class="blue_ctr_botbord" style="width: 20px">
																0</td>
																<td class="blue_ctr_botbord" style="width: 20px">
																1</td>
																<td class="blue_ctr_botbord" style="width: 20px">
																0</td>
																<td class="blue_ctr_botbord" style="width: 20px">
																1</td>
																<td class="blue_ctr_botbord" style="width: 20px">
																0</td>
																<td class="blue_ctr_botbord" style="width: 20px">
																1</td>
																<td class="blue_ctr_botbord" style="width: 20px">
																0</td>
																<td class="blue_ctr_botbord" style="width: 20px">
																1</td>
																<td class="blue_ctr_botbord" style="width: 20px">
																0</td>
																<td class="blue_ctr_botbord" style="width: 20px">
																1</td>
																<td class="blue_ctr_botbord" style="width: 20px">
																0</td>
												</tr>
												<tr>
																<td class="left_topbord">
																Raster 
																Operation&nbsp;</td>
																<td class="center_topbord" style="width: 20px">
																15</td>
																<td class="center_topbord" style="width: 20px">
																14</td>
																<td class="center_topbord" style="width: 20px">
																13</td>
																<td class="center_topbord" style="width: 20px">
																12</td>
																<td class="center_topbord" style="width: 20px">
																11</td>
																<td class="center_topbord" style="width: 20px">
																10</td>
																<td class="center_topbord" style="width: 20px">
																9</td>
																<td class="center_topbord" style="width: 20px">
																8</td>
																<td class="center_topbord" style="width: 20px">
																7</td>
																<td class="center_topbord" style="width: 20px">
																6</td>
																<td class="center_topbord" style="width: 20px">
																5</td>
																<td class="center_topbord" style="width: 20px">
																4</td>
																<td class="center_topbord" style="width: 20px">
																3</td>
																<td class="center_topbord" style="width: 20px">
																2</td>
																<td class="center_topbord" style="width: 20px">
																1</td>
																<td class="center_topbord" style="width: 20px">
																0</td>
												</tr>
								</table>
								<br />
								For example, to specify an operation that uses 
								the mask to choose between source 1 and 
								destination (source 1 when mask is 1, 
								destination when mask is 0), a client would 
								calculate the bottom line by parsing each 
								column:<br />
								<br />
								When mask is 1 (the first eight columns), the
								<span class="inline_code">rop</span> matches the 
								source 1 row.&nbsp; When mask is 0 (the last 
								eight columns), the <span class="inline_code">
								rop</span> matches the destination row.<br />
								<br />
<table class="indent1">
												<tr>
																<td class="left_topbord">
																Raster 
																Operation&nbsp;</td>
																<td class="red_ctr_topbord" style="width: 20px">
																1</td>
																<td class="red_ctr_topbord" style="width: 20px">
																1</td>
																<td class="red_ctr_topbord" style="width: 20px">
																1</td>
																<td class="red_ctr_topbord" style="width: 20px">
																1</td>
																<td class="red_ctr_topbord" style="width: 20px">
																0</td>
																<td class="red_ctr_topbord" style="width: 20px">
																0</td>
																<td class="red_ctr_topbord" style="width: 20px">
																0</td>
																<td class="red_ctr_topbord" style="width: 20px">
																0</td>
																<td class="blu_ctr_topbord" style="width: 20px">
																1</td>
																<td class="blu_ctr_topbord" style="width: 20px">
																0</td>
																<td class="blu_ctr_topbord" style="width: 20px">
																1</td>
																<td class="blu_ctr_topbord" style="width: 20px">
																0</td>
																<td class="blu_ctr_topbord" style="width: 20px">
																1</td>
																<td class="blu_ctr_topbord" style="width: 20px">
																0</td>
																<td class="blu_ctr_topbord" style="width: 20px">
																1</td>
																<td class="blu_ctr_topbord" style="width: 20px">
																0</td>
												</tr>
								</table>
								<br />
								So the <span class="inline_code">rop</span> for 
								this operation would be 0xF0AA.<br />
								<br />
								Here is a list of some commonly used raster 
								operations that have been given names:<br />
								<table class="indent_thick_bord">
												<tr>
																<td class="thin_bord_dbl_botbord">
																<strong>ROP&nbsp;</strong></td>
																<td class="thin_bord_dbl_botbord">
																<strong>Constant</strong></td>
																<td class="thin_bord_dbl_botbord">
																<strong>
																Description</strong></td>
												</tr>
												<tr>
																<td class="thin_bord">
																BLACKNESS</td>
																<td class="thin_bord">
																0x0000</td>
																<td class="thin_bord">
																Set all 
																destination bits 
																to black (0).&nbsp; 
																Dest = 0</td>
												</tr>
												<tr>
																<td class="thin_bord">
																DSTINVERT</td>
																<td class="thin_bord">
																0x5555</td>
																<td class="thin_bord">
																Invert (NOT) the 
																destination 
																bits.&nbsp; Dest&nbsp;= 
																~Dest</td>
												</tr>
												<tr>
																<td class="thin_bord">
																MERGECOPY</td>
																<td class="thin_bord">
																0xC0C0</td>
																<td class="thin_bord">
																Dest = Src1 &amp; 
																Src2</td>
												</tr>
												<tr>
																<td class="thin_bord">
																MERGEPAINT</td>
																<td class="thin_bord">
																0xBBBB</td>
																<td class="thin_bord">
																Dest = ~Src1 | 
																Dest</td>
												</tr>
												<tr>
																<td class="thin_bord">
																NOTSRCCOPY</td>
																<td class="thin_bord">
																0x3333</td>
																<td class="thin_bord">
																Dest = ~Src1</td>
												</tr>
												<tr>
																<td class="thin_bord">
																NOTSRCERASE</td>
																<td class="thin_bord">
																0x1111</td>
																<td class="thin_bord">
																Dest = ~Src1 &amp; ~Dest 
																= ~(Src1 | Dest)</td>
												</tr>
												<tr>
																<td class="thin_bord">
																PATCOPY</td>
																<td class="thin_bord">
																0xF0F0</td>
																<td class="thin_bord">
																Copy source 2 to 
																destination.&nbsp; 
																Dest = Src2</td>
												</tr>
												<tr>
																<td class="thin_bord">
																PATINVERT</td>
																<td class="thin_bord">
																0x5A5A</td>
																<td class="thin_bord">
																XOR with Src2.&nbsp; 
																Dest = Src2 ^ 
																Dest</td>
												</tr>
												<tr>
																<td class="thin_bord">
																PATPAINT</td>
																<td class="thin_bord">
																0xFBFB</td>
																<td class="thin_bord">
																Dest = &nbsp;~Src1 | 
																Src2 | Dest</td>
												</tr>
												<tr>
																<td class="thin_bord">
																SRCAND</td>
																<td class="thin_bord">
																0x8888</td>
																<td class="thin_bord">
																Dest = Src1 &amp; 
																Dest</td>
												</tr>
												<tr>
																<td class="thin_bord">
																SRCCOPY</td>
																<td class="thin_bord">
																0xCCCC</td>
																<td class="thin_bord">
																Dest = Src1</td>
												</tr>
												<tr>
																<td class="thin_bord">
																SRCERASE</td>
																<td class="thin_bord">
																0x4444</td>
																<td class="thin_bord">
																Dest = Src1 &amp; ~Dest</td>
												</tr>
												<tr>
																<td class="thin_bord">
																SRCINVERT</td>
																<td class="thin_bord">
																0x6666</td>
																<td class="thin_bord">
																XOR with Src1.&nbsp; 
																Dest = Src1 ^ 
																Dest</td>
												</tr>
												<tr>
																<td class="thin_bord">
																SRCPAINT</td>
																<td class="thin_bord">
																0xEEEE</td>
																<td class="thin_bord">
																OR with Src1.&nbsp; 
																Dest = Src1 | 
																Dest</td>
												</tr>
												<tr>
																<td class="thin_bord">
																WHITENESS</td>
																<td class="thin_bord">
																0xFFFF</td>
																<td class="thin_bord">
																Set all 
																destination bits 
																to white (1).&nbsp; 
																Dest = 1</td>
												</tr>
								</table>
								<br />
								<span class="Code_Header_2"><a name="blend">bvbltparams.op.blend</a></span>
<p class="code_block">enum bvblend blend; /* input */</p>
<p>When <span class="inline_code"><a href="#BVFLAG_BLEND">BVFLAG_BLEND</a></span> is set in the
<span class="inline_code"><a href="#flags">bvbltparams.flags</a></span> member, the <span class="inline_code">
<a href="#op">bvbltparams.op</a></span> union is treated as a <span class="inline_code">blend</span>.</p>
<p>To specify the blend, the client fills in <span class="inline_code">blend</span> with one of the
								<span class="inline_code"><a href="#bvblend">bvblend</a></span> values.</p>
<p><span class="inline_code"><a href="#bvblend">bvblend</a></span> is an enumeration assembled from sets of fields.&nbsp; 
The values specified may be extended beyond those that are explicitly defined using the definitions in the
<span class="filename">bvblend.h</span> header file.</p>
<p>The first field is a 
								format grouping.&nbsp; Currently two format groups are defined, but others can be added.&nbsp; 
								The remainder of the bits are used as defined by the individual format:</p>
								<table style="width: 100%">
												<tr>
																<td valign="top">1.</td>
																<td><span class="inline_code"><strong>
																<a name="BVBLENDDEF_FORMAT_CLASSIC0">BVBLENDDEF_FORMAT_CLASSIC</a></strong></span> 
																- The classic blending equations are based on the 
																Porter-Duff blending equations, with some additions:<br />
																<br />
																For <span class="inline_code">BVBLENDDEF_FORMAT_CLASSIC</span>, 
																the specific blend operation is constructed using the 
																definitions above. Following the format identifier, the 
																remaining 28 bits are divided into four groups of 6 bits 
																plus 4 modifier bits.<br />
																<br />
																Starting with the following equations:<br />
&nbsp; Cd = K1 x C1 + K2 x C2<br />
&nbsp; Ad = K3 x A1 + K4 x A2<br />
																<br />
																The four 6-bit fields are used to specify the values for 
																the four constant (K) values.<br />
																<br />
																These 6-bit fields are further divided into 3 groups of 
																2 bits each. The rightmost 2 groups specify parameters 
																used as indicated by the leftmost group.<br />
																<br />
																Bits n through n+1 specify the second parameter:<br />
&nbsp; 00b = 1-Cs<br />
&nbsp; 01b = 1-As<br />
&nbsp; 10b = 1-Cd<br />
&nbsp; 11b = 1-Ad<br />
																<br />
																Bits n+2 through n+3 specify the first parameter:<br />
&nbsp; 00b = Cs<br />
&nbsp; 01b = As<br />
&nbsp; 10b = Cd<br />
&nbsp; 11b = Ad<br />
																<br />
																Bits n+4 through n+5 indicate how the two fields are 
																used:<br />
&nbsp; 00b = only the first parameter is used (special case for both 00b)<br />
&nbsp; 01b = minimum of two fields<br />
&nbsp; 10b = maximum of two fields<br />
&nbsp; 11b = only the second parameter is used (special case for both 11b)<br />
																<br />
																Put together, these can define portions of the blend 
																equations that can be put together in a variety of ways:<br />
																<br />
&nbsp; 00 00 00: 0<br />
&nbsp; 00 00 11: C1<br />
&nbsp; 00 01 11: A1<br />
&nbsp; 00 10 11: C2<br />
&nbsp; 00 11 11: A2<br />
&nbsp; 11 00 00: 1-C1<br />
&nbsp; 11 00 01: 1-A1<br />
&nbsp; 11 00 10: 1-C2<br />
&nbsp; 11 00 11: 1-A2<br />
&nbsp; 11 11 11: 1<br />
&nbsp; 01 01 11: min(A1,1-A2)<br />
																<br />
																Putting these together into the proper constants, the 
																blending equations can be built for DirectFB or 
																Porter-Duff:<br />
																<br />
																For Porter-Duff, the equations can be more specifically 
																defined. For convenience, these are defined below. These 
																utilize the local alpha as indicated. To use global or 
																remote alpha, these enumerations need to be modified. 
																For example, to include the global alpha in the 
																Porter-Duff <span class="inline_code">BVBLEND_SRC1OVER</span> 
																blend, the blend could be defined like this:<br />
&nbsp; <span class="inline_code">params.op.blend = BVBLEND_SRC1OVER + BVBLENDDEF_GLOBAL_UCHAR;</span><br />
																<br />
																To include the remote alpha, the blend could be defined 
																like this:<br />
&nbsp; <span class="inline_code">params.op.blend = BVBLEND_SRC1OVER + BVBLENDDEF_REMOTE;</span><br />
																<br />
																And to include both:<br />
&nbsp; <span class="inline_code">params.op.blend = BVBLEND_SRC1OVER + BVBLENDDEF_GLOBAL_UCHAR + BVBLENDDEF_REMOTE;</span><br />
																<br />
																Note that if the source color formats include local 
																alphas, the local alphas, global alpha, and remote alpha 
																will be used together.<br />
																<br />
																Note also that the equations assume the surfaces are 
																premultiplied. So if the surface formats indicate that 
																they are not premultiplied, the alpha multiplication of 
																each color is done prior to using the surface values in 
																the equations.&nbsp; For example,
																<span class="inline_code">BVBLEND_SRC1OVER</span> 
																specifies the equations:<br />
&nbsp; Cd = C1 x 1 + C2 x (1 - A1)<br />
&nbsp; Ad = A1 x 1 + A2 x (1 - A1)<br />
																If the format of surface 1 is non-premultiplied, the 
																equations are modified to include the multiplication 
																explicitly:<br />
&nbsp; Cd = C1 x A1 x 1 + C2 x (1 - A1)<br />
&nbsp; Ad = A1 x 1 + A2 x (1 - A1)<br />
																Likewise, if the format of surface 2 is non-premultiplied, 
																the equations are modified for this:<br />
&nbsp; Cd = C1 x 1 + C2 x A2 x (1 - A1)<br />
&nbsp; Ad = A1 x 1 + A2 x (1 - A1)<br />
																<br />
																For DirectFB, the <span class="inline_code">
																SetSrcBlendFunction()</span> and
																<span class="inline_code">SetDstBlendFunction()</span> 
																can specify 121 combinations of blends (11 x 11). It&#39;s 
																impractical to specify these combinations individually. 
																Instead, the settings indicated by each call should be 
																bitwise OR&#39;d to make the proper single value used in 
																BLTsville.<br />
																<br />
																<span class="inline_code">binary value &lt;- 
																SetSrcBlendFunction()<br />
																[--K1--] [--K2--] [--K3--] [--K4--]<br />
																00000000 00 00 00 xx xx xx 00 00 00 xx xx xx &lt;- 
																DSBF_ZERO<br />
																00000000 11 11 11 xx xx xx 11 11 11 xx xx xx &lt;- DSBF_ONE<br />
																00000000 00 00 11 xx xx xx 00 01 11 xx xx xx &lt;- 
																DSBF_SRCCOLOR<br />
																00000000 11 00 00 xx xx xx 11 00 01 xx xx xx &lt;- 
																DSBF_INVSRCCOLOR<br />
																00000000 00 01 11 xx xx xx 00 01 11 xx xx xx &lt;- 
																DSBF_SRCALPHA<br />
																00000000 11 00 01 xx xx xx 11 00 01 xx xx xx &lt;- 
																DSBF_INVSRCALPHA<br />
																00000000 00 11 11 xx xx xx 00 11 11 xx xx xx &lt;- 
																DSBF_DESTALPHA<br />
																00000000 11 00 11 xx xx xx 11 00 11 xx xx xx &lt;- 
																DSBF_INVDESTALPHA<br />
																00000000 00 10 11 xx xx xx 00 11 11 xx xx xx &lt;- 
																DSBF_DESTCOLOR<br />
																00000000 11 00 10 xx xx xx 11 00 11 xx xx xx &lt;- 
																DSBF_INVDESTCOLOR<br />
																00000000 01 01 11 xx xx xx 11 11 11 xx xx xx &lt;- 
																DSBF_SRCALPHASAT<br />
																</span><br />
																<span class="inline_code">binary value &lt;- 
																SetDstBlendFunction()<br />
																00000000 xx xx xx 00 00 00 xx xx xx 00 00 00 &lt;- 
																DSBF_ZERO<br />
																00000000 xx xx xx 11 11 11 xx xx xx 11 11 11 &lt;- DSBF_ONE<br />
																</span>etc.<br />
																<br />
																The following are modifiers of the classic blend 
																equation:<br />
&nbsp; <span class="inline_code">BVBLENDDEF_REMOTE</span> - mask surface provides alpha for source 1<br />
																<br />
&nbsp; <span class="inline_code">BVBLENDDEF_GLOBAL_NONE</span> - no global alpha in use<br />
&nbsp; <span class="inline_code">BVBLENDDEF_GLOBAL_UCHAR</span> - global alpha is an 8-bit value from 0 (0.0) to 255 
																(1.0) <br />
&nbsp; <span class="inline_code">BVBLENDDEF_GLOBAL_FLOAT</span> - global alpha is a floating point value from 0.0 to 1.0<br />
																</td>
												</tr>
												<tr>
																<td valign="top">2.</td>
																<td><span class="inline_code">
																<strong><a name="BVBLENDDEF_FORMAT_ESSENTIAL0">BVBLENDDEF_FORMAT_ESSENTIAL</a></strong></span><br />
																<br />
																The essential blending equations are based on the 
																blending equations in common image manipulation 
																programs.<pre><code>BVBLEND_LIGHTEN   &nbsp;  max(src1, src2)
BVBLEND_DARKEN       min(src1, src2)
BVBLEND_MULTIPLY     (src1 * src2) / 255
BVBLEND_AVERAGE   &nbsp;  (src1 + src2) / 2
BVBLEND_ADD       &nbsp;  src1 + src2 (saturated)
BVBLEND_SUBTRACT     src1 + src2 - 255 (saturated)
BVBLEND_DIFFERENCE   abs(src - src2)
BVBLEND_NEGATION     255 - abs(255 - src1 - src2)
BVBLEND_SCREEN       255 - (((255 - src1) * (255 - src2)) / 256)
BVBLEND_EXCLUSION &nbsp;  src1 + src2 - ((2 * src1 * src2) / 255)
BVBLEND_OVERLAY   &nbsp;  (src2 &lt; 128) ? (2 * src1 * src2 / 255) : (255 - 2 * (255 - src1) * (255 - src2) / 255)
BVBLEND_SOFT_LIGHT &nbsp; (src2 &lt; 128) ? (2 * ((src1 &gt;&gt; 1) + 64)) * ((float)src2 / 255) : (255 - (2 * (255 - ((src1 &gt;&gt; 1) + 64)) * (float)(255 - src2) / 255))
BVBLEND_HARD_LIGHT &nbsp; (src1 &lt; 128) ? (2 * src2 * src1 / 255) : (255 - 2 * (255 - src2) * (255 - src1) / 255)
BVBLEND_COLOR_DODGE  (src2 == 255) ? src2 : min(255, ((src1 &lt;&lt; 8) / (255 - src2))
BVBLEND_COLOR_BURN &nbsp; (src2 == 0) ? src2 : max(0, (255 - ((255 - src1) &lt;&lt; 8 ) / src2))))
BVBLEND_LINEAR_DODGE same as BVBLEND_ADD
BVBLEND_LINEAR_BURN  same as BVBLEND_SUBTRACT
BVBLEND_LINEAR_LIGHT (src2 &lt; 128) ? LINEAR_BURN(src1,(2 * src2)) : LINEAR_DODGE(src1,(2 * (src2 - 128)))
BVBLEND_VIVIDL_IGHT  (src2 &lt; 128) ? COLOR_BURN(src1,(2 * src2)) : COLOR_DODGE(src1,(2 * (src2 - 128))))
BVBLEND_PIN_LIGHT    (src2 &lt; 128) ? DARKEN(src1,(2 * src2)) : LIGHTEN(src1,(2 * (src2 - 128)))
BVBLEND_HARD_MIX   &nbsp; (VIVID_LIGHT(src1, src2) &lt; 128) ? 0 : 255
BVBLEND_REFLECT   &nbsp;  (src2 == 255) ? src2 : min(255, (src1 * src1 / (255 - src2)))
BVBLEND_GLOW         (src1 == 255) ? src1 : min(255, (src2 * src2 / (255 - src1)))
BVBLEND_PHOENIX   &nbsp;  min(src1, src2) - max(src1, src2) + 255)
BVBLEND_ALPHA     &nbsp;  alf * src1 + (1 - alf) * src2)
</code></pre>
																</td>
												</tr>
								</table>
								<a name="filter" class="Code_Header_2">bvbltparams.op.filter</a>
<p class="code_block">struct bvfilter *filter; /* input */</p>
<p>When <span class="inline_code"><a href="#BVFLAG_FILTER">BVFLAG_FILTER</a></span> is set in the
<span class="inline_code"><a href="#flags">bvbltparams.flags</a></span> member, the <span class="inline_code">
<a href="#op">bvbltparams.op</a></span> union is treated as a <span class="inline_code">filter</span>.</p>
<p>To specify the filter, the client fills in <span class="inline_code">filter</span> with one of the
								<span class="inline_code">bvfilter</span> values.</p>
<p>These values will be extended as general filter types are requested.</p>
<a name="colorkey" class="Code_Header_2">bvbltparams.colorkey</a>
<p class="code_block">void *colorkey; /* input */</p>
<p>When either <span class="inline_code"><a href="#BVFLAG_KEY_SRC">BVFLAG_KEY_SRC</a></span> or
<span class="inline_code"><a href="#BVFLAG_KEY_DST">BVFLAG_KEY_DST</a></span> is set in the <span class="inline_code"><a href="#flags">bvbltparams.flags</a></span> member,
<span class="inline_code">colorkey</span> points to a single pixel used as the color key.</p>
<p>The format of this pixel matches the surface being keyed.&nbsp; i.e. <span class="inline_code"><a href="#bvsurfgeom">src1geom.format</a></span> is the format of the color key if
<span class="inline_code">BVFLAG_KEY_SRC</span> is set, or <span class="inline_code"><a href="#bvsurfgeom">dst.format</a></span> 
is the format of the color key if <span class="inline_code">BVFLAG_KEY_DST</span> is set.</p>
<p><em>SSubsampled formats do not currently support color keying.</em></p>
<p class="Code_Header_2"><a name="globalalpha">bvbltparams.globalalpha</a></p>
<p class="code_block">union bvalpha globalalpha; /* input */</p>
<p>When <span class="inline_code"><a href="#BVFLAG_BLEND">BVFLAG_BLEND</a></span> is set in the
<span class="inline_code"><a href="#flags">bvbltparams.flags</a></span>, and when the <span class="inline_code">
<a href="#blend">blend</a></span> chosen requires it, <span class="inline_code">globalalpha</span> is used to provide an 
alpha blending value for the entire operation.&nbsp; The type is also dependent on the <span class="inline_code">
<a href="#blend">blend</a></span> chosen.</p>
<p>For the <span class="inline_code">BVBLENDDEF_FORMAT_CLASSIC</span> blend types, if the <span class="inline_code">
BVBLENDDEF_GLOBAL_MASK</span> field is not 0, this field is used.&nbsp; Currently <span class="inline_code">
BVBLENDDEF_FORMAT_CLASSIC</span> provides for an 8-bit (unsigned character / byte) format designated by
<span class="inline_code">BVBLENDDEF_GLOBAL_UCHAR</span> as well as a 32-bit floating point format designated by
<span class="inline_code">BVBLENDDEF_GLOBAL_FLOAT</span>.</p>
<p class="Code_Header_2"><a name="scalemode">bvbltparams.scalemode</a></p>
<p class="code_block">enum bvscalemode scalemode; /* input/output */</p>
<p>This member allows the client to specify the type of scaling to be used.&nbsp; The enumeration 
begins with 8 bits 
indicating the vendor.&nbsp; The remaining bits are defined by the vendor.&nbsp; <span class="inline_code">
BVSCALEDEF_VENDOR_ALL</span> and <span class="inline_code">BVSCALEDEF_VENDOR_GENERAL</span> 
are shared by all 
implementations.</p>
<p><span class="inline_code">BVSCALEDEF_VENDOR_ALL</span> can be used to specify an implicit scale type.&nbsp; This type 
is converted to an explicit type by the implementation:</p>
<table>
				<tr>
								<td class="inline_code">BVSCALE_FASTEST</td>
								<td>The fastest method of scaling available is used.&nbsp; This may include nearest 
								neighbor.&nbsp; The value of this enumeration is purposely 0, and is the default scale 
								type.&nbsp; No implementation will return an error for this setting.</td>
				</tr>
				<tr>
								<td class="inline_code">BVSCALE_FASTEST_NOT_NEAREST_NEIGHBOR</td>
								<td>The fastest method of scaling available that is not nearest neighbor is used.&nbsp; 
								This may include an alternative point sample technique.</td>
				</tr>
				<tr>
								<td class="inline_code">BVSCALE_FASTEST_POINT_SAMPLE</td>
								<td>The fastest method of scaling using a point sample technique.</td>
				</tr>
				<tr>
								<td class="inline_code">BVSCALE_FASTEST_INTERPOLATED</td>
								<td>The fastest method of scaling using an interpolation technique.</td>
				</tr>
				<tr>
								<td class="inline_code">BVSCALE_FASTEST_PHOTO</td>
								<td>The fastest method of scaling appropriate for photographs is used.&nbsp; 
								This may include nearest neighbor.&nbsp; No 
								implementation will return an error for this setting.</td>
				</tr>
				<tr>
								<td class="inline_code">BVSCALE_FASTEST_DRAWING</td>
								<td>The fastest method of scaling appropriate for drawings is used.&nbsp; 
								This may include nearest neighbor.&nbsp; No 
								implementation will return an error for this setting.</td>
				</tr>
				<tr>
								<td class="inline_code">BVSCALE_GOOD</td>
								<td>A scaling technique is chosen that may be higher quality than the
								<span class="inline_code">BVSCALE_FASTEST</span> choice.&nbsp; 
								This may include nearest neighbor.&nbsp; No implementation will 
								return an error for this setting.</td>
				</tr>
				<tr>
								<td class="inline_code">BVSCALE_GOOD_POINT_SAMPLE</td>
								<td>A point sample scaling technique is chosen that may be higher quality than the
								<span class="inline_code">BVSCALE_FASTEST_POINT_SAMPLE</span> choice.&nbsp; 
								This may include nearest neighbor.</td>
				</tr>
				<tr>
								<td class="inline_code">BVSCALE_GOOD_INTERPOLATED</td>
								<td>An interpolated scaling technique is chosen that may be higher quality than the
								<span class="inline_code">BVSCALE_FASTEST_INTERPOLATED</span> choice.</td>
				</tr>
				<tr>
								<td class="inline_code">BVSCALE_GOOD_PHOTO</td>
								<td>A scaling technique appropriate for photographs is chosen that may be higher quality 
								than the <span class="inline_code">BVSCALE_FASTEST_PHOTO</span> choice.&nbsp; 
								This may include nearest neighbor.&nbsp; No 
								implementation will return an error for this setting.</td>
				</tr>
				<tr>
								<td class="inline_code">BVSCALE_GOOD_DRAWING</td>
								<td>A scaling technique appropriate for drawings is chosen that may be higher quality 
								than the <span class="inline_code">BVSCALE_FASTEST_DRAWING</span> choice.&nbsp; 
								This may include nearest neighbor.&nbsp; No 
								implementation will return an error for this setting.</td>
				</tr>
				<tr>
								<td class="inline_code">BVSCALE_BETTER</td>
								<td>A scaling technique is chosen that may be higher quality than the
								<span class="inline_code">BVSCALE_GOOD</span> choice.&nbsp; 
								This may include nearest neighbor.&nbsp; No implementation will 
								return an error for this setting.</td>
				</tr>
				<tr>
								<td class="inline_code">BVSCALE_BETTER_POINT_SAMPLE</td>
								<td>A point sample scaling technique is chosen that may be higher quality than the
								<span class="inline_code">BVSCALE_GOOD_POINT_SAMPLE</span> choice.&nbsp; 
								This may include nearest neighbor.</td>
				</tr>
				<tr>
								<td class="inline_code">BVSCALE_BETTER_INTERPOLATED</td>
								<td>An interpolated scaling technique is chosen that may be higher quality than the
								<span class="inline_code">BVSCALE_GOOD_INTERPOLATED</span> choice.</td>
				</tr>
				<tr>
								<td class="inline_code">BVSCALE_BETTER_PHOTO</td>
								<td>A scaling technique appropriate for photographs is chosen that may be higher quality 
								than the <span class="inline_code">BVSCALE_GOOD_PHOTO</span> choice.&nbsp; 
								This may include nearest neighbor.&nbsp; No 
								implementation will return an error for this setting.</td>
				</tr>
				<tr>
								<td class="inline_code">BVSCALE_BETTER_DRAWING</td>
								<td>A scaling technique appropriate for drawings is chosen that may be higher quality 
								than the <span class="inline_code">BVSCALE_GOOD_DRAWING</span> choice.&nbsp; 
								This may include nearest neighbor.&nbsp; No 
								implementation will return an error for this setting.</td>
				</tr>
				<tr>
								<td class="inline_code">BVSCALE_BEST</td>
								<td>The highest quality scaling technique is chosen.&nbsp; 
								This may include nearest neighbor.&nbsp; No implementation will return 
								an error for this setting.</td>
				</tr>
				<tr>
								<td class="inline_code">BVSCALE_BEST_POINT_SAMPLE</td>
								<td>The highest quality point sample technique is chosen.</td>
				</tr>
				<tr>
								<td class="inline_code">BVSCALE_BEST_INTERPOLATED</td>
								<td>The highest quality interpolated scaling technique is chosen.</td>
				</tr>
				<tr>
								<td class="inline_code">BVSCALE_BEST_PHOTO</td>
								<td>The highest quality scaling technique appropriate for photographs is chosen.&nbsp; 
								This may include nearest neighbor.&nbsp; 
								No implementation will return an error for this setting.</td>
				</tr>
				<tr>
								<td class="inline_code">BVSCALE_BEST_DRAWING</td>
								<td>The highest quality scaling technique appropriate for drawings is chosen.&nbsp; 
								This may include nearest neighbor.&nbsp; No 
								implementation will return an error for this setting.</td>
				</tr>
</table>
<br/>
<span class="inline_code">BVSCALEDEF_VENDOR_GENERAL</span> can be used to specify one of the shared explicit scale 
types.&nbsp; At this point, only a limited number of explicit scale types are defined:
<br/>
<br/>
<table>
				<tr>
								<td class="inline_code">BVSCALE_NEAREST_NEIGHBOR</td>
								<td>This is a point sample scaling technique where the resampled destination pixel is 
								set to the value of the closest source pixel.</td>
				</tr>
				<tr>
								<td class="inline_code">BVSCALE_BILINEAR</td>
								<td>This is an interpolated scaling technique where the resampled destination pixel is 
								set to a value linearly interpolated in two dimensions from the four closest source 
								pixels.</td>
				</tr>
				<tr>
								<td class="inline_code">BVSCALE_BICUBIC</td>
								<td>This is an interpolated scaling technique where the resampled destination pixel is 
								set to a value calculated using cubic interpolation in two dimensions.</td>
				</tr>
				<tr>
								<td class="inline_code">BVSCALE_3x3_TAP</td>
								<td>&nbsp;</td>
				</tr>
				<tr>
								<td class="inline_code">BVSCALE_5x5_TAP</td>
								<td>&nbsp;</td>
				</tr>
				<tr>
								<td class="inline_code">BVSCALE_7x7_TAP</td>
								<td>&nbsp;</td>
				</tr>
				<tr>
								<td class="inline_code">BVSCALE_9x9_TAP</td>
								<td>&nbsp;</td>
				</tr>
</table>
<p>If the client wants to know the explicit type chosen by a given implementation, it can set <span class="inline_code">
BVFLAG_SCALE_RETURN</span> 
in the <span class="inline_code"><a href="#flags">bvbltparams.flags</a></span> member, and the explicit scale type is 
returned in the <span class="inline_code">scalemode</span> member.</p>
<p>NOTE:&nbsp; Extending the <span class="inline_code">BVSCALEDEF_VENDOR_GENERAL</span> scale types or obtaining a 
vendor ID can be accomplished by submitting a patch.</p>
<p class="Code_Header_2"><a name="dithermode">bvbltparams.dithermode</a></p>
<p class="code_block">enum bvdithermode dithermode; /* input/output */</p>
<p>This member allows the client to specify the type of dithering to be used, 
when the output format has fewer bits of depth than the internal calculation.&nbsp; 
The enumeration begins with 8 bits 
indicating the vendor.&nbsp; The remaining bits are defined by the vendor.&nbsp; <span class="inline_code">
BVDITHERDEF_VENDOR_ALL</span> and <span class="inline_code">BVDITHERDEF_VENDOR_GENERAL</span> 
are shared by all 
implementations.</p>
<p><span class="inline_code">BVDITHERDEF_VENDOR_ALL</span> can be used to specify an implicit 
dither type.&nbsp; This type 
is converted to an explicit type by the implementation:</p>
<table>
				<tr>
								<td class="inline_code">BVDITHER_FASTEST</td>
								<td>The fastest method of dithering available is used.&nbsp; This may include 
								no dithering (truncation).&nbsp; The value of this enumeration is purposely 0, and is the default 
								dither 
								type.&nbsp; No implementation will return an error for this setting.</td>
				</tr>
				<tr>
								<td class="inline_code">BVDITHER_FASTEST_ON</td>
								<td>The fastest method of dithering available is used.&nbsp; 
								This will not include no dithering.</td>
				</tr>
				<tr>
								<td class="inline_code">BVDITHER_FASTEST_RANDOM</td>
								<td>The fastest method of dithering using a 
								random technique.</td>
				</tr>
				<tr>
								<td class="inline_code">BVDITHER_FASTEST_ORDERED</td>
								<td>The fastest method of dithering using an 
								ordered diffusion technique.</td>
				</tr>
				<tr>
								<td class="inline_code">
								BVDITHER_FASTEST_DIFFUSED</td>
								<td>The fastest method of dithering using an 
								error diffusion technique.</td>
				</tr>
				<tr>
								<td class="inline_code">BVDITHER_FASTEST_PHOTO</td>
								<td>The fastest method of dithering appropriate for photographs is used.&nbsp; 
								This may include no dithering.&nbsp; No 
								implementation will return an error for this setting.</td>
				</tr>
				<tr>
								<td class="inline_code">BVDITHER_FASTEST_DRAWING</td>
								<td>The fastest method of dithering appropriate for drawings is used.&nbsp; 
								This may include no dithering.&nbsp; No 
								implementation will return an error for this setting.</td>
				</tr>
				<tr>
								<td class="inline_code">BVDITHER_GOOD</td>
								<td>A dithering technique is chosen that may be higher quality than the
								<span class="inline_code">BVDITHER_FASTEST</span> choice.&nbsp; 
								This may include no dithering.&nbsp; No implementation will 
								return an error for this setting.</td>
				</tr>
				<tr>
								<td class="inline_code">BVDITHER_GOOD_RANDOM</td>
								<td>A random dithering technique is chosen that may be higher quality than the
								<span class="inline_code">BVDITHER_FASTEST_RANDOM</span> choice.</td>
				</tr>
				<tr>
								<td class="inline_code">BVDITHER_GOOD_ORDERED</td>
								<td>An ordered dithering technique is chosen that may be higher quality than the
								<span class="inline_code">BVDITHER_FASTEST_ORDERED</span> choice.</td>
				</tr>
				<tr>
								<td class="inline_code">BVDITHER_GOOD_DIFFUSED</td>
								<td>A diffused dithering technique is chosen 
								that may be higher quality than the
								<span class="inline_code">
								BVDITHER_FASTEST_DIFFUSED</span> choice.</td>
				</tr>
				<tr>
								<td class="inline_code">BVDITHER_GOOD_PHOTO</td>
								<td>A dithering technique appropriate for photographs is chosen that may be higher quality 
								than the <span class="inline_code">BVDITHER_FASTEST_PHOTO</span> choice.&nbsp; 
								This may include no dithering.&nbsp; No 
								implementation will return an error for this setting.</td>
				</tr>
				<tr>
								<td class="inline_code">BVDITHER_GOOD_DRAWING</td>
								<td>A dithering technique appropriate for drawings is chosen that may be higher quality 
								than the <span class="inline_code">BVDITHER_FASTEST_DRAWING</span> choice.&nbsp; 
								This may include no dithering.&nbsp; No 
								implementation will return an error for this setting.</td>
				</tr>
				<tr>
								<td class="inline_code">BVDITHER_BETTER</td>
								<td>A dithering technique is chosen that may be higher quality than the
								<span class="inline_code">BVDITHER_GOOD</span> choice.&nbsp; 
								This may include no dithering.&nbsp; No implementation will 
								return an error for this setting.</td>
				</tr>
				<tr>
								<td class="inline_code">BVDITHER_BETTER_RANDOM</td>
								<td>A random dithering technique is chosen that may be higher quality than the
								<span class="inline_code">BVDITHER_GOOD_RANDOM</span> choice.</td>
				</tr>
				<tr>
								<td class="inline_code">BVDITHER_BETTER_ORDERED</td>
								<td>An ordered dithering technique is chosen that may be higher quality than the
								<span class="inline_code">BVDITHER_GOOD_ORDERED</span> choice.</td>
				</tr>
				<tr>
								<td class="inline_code">BVDITHER_BETTER_DIFFUSED</td>
								<td>A diffused dithering technique is chosen 
								that may be higher quality than the
								<span class="inline_code">BVDITHER_GOOD_DIFFUSED</span> 
								choice.</td>
				</tr>
				<tr>
								<td class="inline_code">BVDITHER_BETTER_PHOTO</td>
								<td>A scaling technique appropriate for photographs is chosen that may be higher quality 
								than the <span class="inline_code">BVSCALE_GOOD_PHOTO</span> choice.&nbsp; No 
								implementation will return an error for this setting.</td>
				</tr>
				<tr>
								<td class="inline_code">BVDITHER_BETTER_DRAWING</td>
								<td>A scaling technique appropriate for drawings is chosen that may be higher quality 
								than the <span class="inline_code">BVSCALE_GOOD_DRAWING</span> choice.&nbsp; No 
								implementation will return an error for this setting.</td>
				</tr>
				<tr>
								<td class="inline_code">BVDITHER_BEST</td>
								<td>The highest quality dithering technique is chosen.&nbsp; 
								This may include no dithering.&nbsp; No implementation will return 
								an error for this setting.</td>
				</tr>
				<tr>
								<td class="inline_code">BVDITHER_BEST_RANDOM</td>
								<td>The highest quality random dithering technique is chosen.</td>
				</tr>
				<tr>
								<td class="inline_code">BVDITHER_BEST_ORDERED</td>
								<td>The highest quality ordered dithering technique is chosen.</td>
				</tr>
				<tr>
								<td class="inline_code">BVDITHER_BEST_DIFFUSED</td>
								<td>The highest quality diffused dithering 
								technique is chosen.</td>
				</tr>
				<tr>
								<td class="inline_code">BVDITHER_BEST_PHOTO</td>
								<td>The highest quality dithering technique appropriate for photographs is chosen.&nbsp; 
								This may include no dithering.&nbsp; 
								No implementation will return an error for this setting.</td>
				</tr>
				<tr>
								<td class="inline_code">BVDITHER_BEST_DRAWING</td>
								<td>The highest quality dithering technique appropriate for drawings is chosen.&nbsp; 
								This may include no dithering.&nbsp; No 
								implementation will return an error for this setting.</td>
				</tr>
</table>
<br/>
<span class="inline_code">BVDITHERDEF_VENDOR_GENERAL</span> can be used to specify one of the shared explicit 
dithering types.&nbsp; At this point, only a limited number of explicit dither types are defined:
<br/>
<br/>
<table>
				<tr>
								<td class="inline_code">BVDITHER_NONE</td>
								<td>No dithering is performed.&nbsp; Internal 
								pixel component values are truncated to the 
								destination component bit depth.</td>
				</tr>
				<tr>
								<td class="inline_code">BVDITHER_ORDERED_2x2</td>
								<td>&nbsp;</td>
				</tr>
				<tr>
								<td class="inline_code">BVDITHER_ORDERED_4x4</td>
								<td>&nbsp;</td>
				</tr>
				<tr>
								<td class="inline_code">BVDITHER_ORDERED_2x2_4x4</td>
								<td>2x2 ordered dither is used for components 
								with the lowest bit reduction.&nbsp; 4x4 ordered 
								dither is used for the components with the 
								highest bit reduction.&nbsp; (E.g. RGB24 to 
								RGB565 will use 2x2 ordered dither for the green 
								component and 4x4 ordered dither for the red and 
								blue components.)</td>
				</tr>
				</table>
<p>If the client wants to know the explicit type chosen by a given implementation, it can set <span class="inline_code">
BVFLAG_DITHER_RETURN</span> 
in the <span class="inline_code"><a href="#flags">bvbltparams.flags</a></span> member, and the explicit scale type is 
returned in the <span class="inline_code">dithermode</span> member.</p>
<p>NOTE:&nbsp; Extending the <span class="inline_code">BVDITHERDEF_VENDOR_GENERAL</span> scale types or obtaining a 
vendor ID can be accomplished by submitting a patch.</p>
<p class="Code_Header_2"><a name="dstdesc">bvbltparams.dstdesc</a></p>
<p class="code_block"><a href="#bvbuffdesc">struct bvbuffdesc</a> *dstdesc;</p>
<p><span class="inline_code">dstdesc</span> is used to specify the destination 
buffer.&nbsp; If the buffer has not been mapped with a call to
<span class="inline_code"><a href="#bv_map">bv_map()</a></span>, <span class="inline_code"><a href="#bv_blt">bv_blt()</a></span>  will map the 
buffer as necessary to perform the BLT and then unmap afterwards.&nbsp; See
<span class="inline_code"><a href="#bvbuffdesc">bvbuffdesc</a></span> for 
details.</p>
<p class="Code_Header_2"><a name="dstgeom">bvbltparams.dstgeom</a></p>
<p class="code_block"><a href="#bvsurfgeom">struct bvsurfgeom</a> *dstgeom;</p>
<p><span class="inline_code">dstgeom</span> is used to specify the geometry of 
the surface contained in the destination buffer.&nbsp; See
<span class="inline_code"><a href="#bvsurfgeom">bvsurfgeom</a></span> for 
details.</p>
<p class="Code_Header_2"><a name="dstrect">bvbltparams.dstrect</a></p>
<p class="code_block"><a href="#bvrect">struct bvrect</a> dstrect;</p>
<p><span class="inline_code">dstrect</span> is used to specify the destination 
rectangle to receive the BLT.&nbsp; This rectangle is clipped by
<span class="inline_code"><a href="#cliprect">bvbltparams.cliprect</a></span> 
when <span class="inline_code"><a href="#BVFLAG_CLIP">BVFLAG_CLIP</a></span> is 
set in the <span class="inline_code"><a href="#flags">bvbltparams.flags</a></span> 
member.</p>
<p class="Code_Header_2">bvbltparams.src1/src2/mask.desc</p>
<p class="Code_Header_2">bvbltparams.src1/src2/ask.tileparams</p>
<p class="Code_Header_2">bvbltparams.src1/src2/maskgeom</p>
<p class="Code_Header_2">bbvbltparams.src1/src2/maskrect</p>
<p class="Code_Header_2">bvbltparams.cliprect</p>
<p class="Code_Header_2">bvbltparams.batchflags</p>
<p class="Code_Header_2">bvbltparams.batch</p>
<p class="Code_Header_2">bvbltparams.callbackfn</p>
<p class="Code_Header_2">bvbltparams.callbackdata</p>
<hr />
<p class="Header1">Where to Start</p>
<p><em>(Note that error checking is omitted in all the examples below for 
clarity.)</em>&nbsp;</p>
<p>1.&nbsp; Clients begin by opening one or more BLTsville implementations 
dynamically.&nbsp; The specific method of doing this is dependent on the 
operating system.&nbsp; For example, Linux might do this like this:</p>

<p class="small_code_block">struct bltsvillelib<br />
{<br />
&nbsp; char* name;<br />
&nbsp; void* handle;<br />
&nbsp; BVFN_MAP bv_map;<br />
&nbsp; BVFN_BLT bv_blt;<br />
&nbsp; BVFN_UNMAP bv_unmap;<br />

};&nbsp;<br />
<br />
struct bltsville bvlib[] =<br />
{<br />
&nbsp; { &quot;libbltsville_cpu.so&quot;, 0 },<br />
&nbsp; { &quot;libbltsville_2d.so&quot;, 0 }<br />

};<br />
const int NUMBVLIBS = sizeof(bvlib) / sizeof(struct bltsvillelib);<br />
<br />
for(int i = 0; i &lt; NUMLIBS; i++)<br />
{<br />
&nbsp; bvlib[i].handle = dlopen(bvlib[i].name, RTLD_LOCAL | RTLD_LAZY);<br />
&nbsp; bvlib[i].bv_map = (BVFN_MAP)dlsym(bvlib[i].handle, &quot;bv_map&quot;);<br />

&nbsp; bvlib[i].bv_blt = (BVFN_BLT)dlsym(bvlib[i].handle, &quot;bv_blt&quot;);<br />
&nbsp; bvlib[i].bv_unmap = (BVFN_BLT)dlsym(bvlib[i].handle, &quot;bv_unmap&quot;);<br />
}<br />
</p>
<p>222.&nbsp; Clients then need to create a <span class="inline_code">

<a href="#bvbuffdesc">bvbuffdesc</a></span> object for each buffer to be 
accessed in BLTsville:</p>
<table class="indent1">
				<tr>
								<td valign="top">
								<p class="small_code_block_in_table">struct 
								bvbuffdesc 
								buff =<br />

&nbsp; {sizeof(struct bvbuffdesc), 0};<br />
								<br />
								buff.virtaddr = buffptr;<br />
								buff.length = bufflength;</p>
								</td>
								<td style="width: 30px" class="center">or</td>
								<td valign="top">

								<p class="inline_code">
								<span class="small_code_block_in_table">struct 
								bvbuffdesc buff;<br />
								<br />
								memset(&amp;buff, 0, sizeof(buff));<br />
								buff.structsize = sizeof(buff);<br />
								buff.virtaddr = buffptr;<br />

								buff.length = bufflength;</span></p>
								</td>
				</tr>
</table>
<p class="strong_emphasis">Note that the client must ensure that the map element and any additional members 
in <span class="inline_code"><a href="#bvbuffdesc">bvbuffdesc</a></span> are 
initialized to 0.</p>
<p>3.&nbsp; Next the buffer can be mapped to give the hardware implementations 
a chance to associate any necessary resources&nbsp;with the buffer:</p>

<table class="indent1">
				<tr>
								<td valign="top">
								<p class="small_code_block_in_table">/* do 
								nothing */&nbsp;</p>
								</td>
								<td style="width: 30px" class="center">or</td>
								<td valign="top">
								<p class="small_code_block_in_table">bvlib[0].bv_map(&amp;buff)&nbsp;</p>

								</td>
								<td style="width: 30px" class="center">or</td>
								<td valign="top">
								<p class="small_code_block_in_table">for(int i = 
								0; i &lt; NUMLIBS; i++)<br />
								{<br />
&nbsp; if(bvlib[i].bv_map)<br />

&nbsp;&nbsp;&nbsp; bvlib[i].bv_map(&amp;buff);<br />
								}</p>
								</td>
				</tr>
</table>
<br/>
<table style="width: 100%">
				<tr>
								<td valign="top">a.&nbsp;</td>

								<td>This step is actually optional, as indicated 
								above.&nbsp; However, if the client does not 
								explicitly call <span class="inline_code">
								<a href="#bv_map">bv_map()</a></span>, the 
								mapping must be done by the implementation to 
								associate the necessary resources with the 
								buffer.&nbsp; So this mapping must be done 
								later, when <span class="inline_code">
								<a href="#bv_blt">bv_blt()</a></span> is called.&nbsp; 
								Additionally, since the client did not call
								<span class="inline_code"><a href="#bv_map">

								bv_map()</a></span>, it is unlikely that the 
								client will call <span class="inline_code">
								<a href="#bv_unmap">bv_unmap()</a></span> to 
								allow the implementation to free the resources 
								associated with the buffer.&nbsp; So the 
								implementation will internally unmap the 
								resources after completing the BLT.&nbsp; This 
								means that the mapping and unmapping overhead 
								will be encountered on every call to
								<span class="inline_code"><a href="#bv_blt">
								bv_blt()</a></span>.<br />

								<em><br />
								In general, the CPU implementations have 
								(almost) no overhead associated with mapping and 
								unmapping.&nbsp; So opting not to make the
								<span class="inline_code"><a href="#bv_map">
								bv_map()</a></span> call for CPU implementations 
								is likely to have negligible difference in 
								<span class="inline_code"><a href="#bv_blt">bv_blt()</a></span> performance.<br />
								</em></td>

				</tr>
				<tr>
								<td valign="top">b.&nbsp;</td>
								<td>Calling <span class="inline_code">
								<a href="#bv_map">bv_map()</a></span> once for each buffer is 
								enough to tell the implementations that the 
								client can be trusted to call
								<span class="inline_code"><a href="#bv_unmap">bv_unmap()</a></span> 
								when work with the buffer is complete, as 
								indicated above.&nbsp; It does not matter which 
								implementation&#39;s <span class="inline_code">

								<a href="#bv_map">bv_map()</a></span> is called.&nbsp; 
								However, that implementation is the only one 
								which will perform the mapping immediately.&nbsp; 
								All other implementations will perform a <em>
								lazy mapping</em> only when their
								<span class="inline_code"><a href="#bv_blt">
								bv_blt()</a></span> call is invoked.<br />

								<br />
								This allows the client to avoid the overhead of 
								mapping and unmapping the buffers on each
								<span class="inline_code"><a href="#bv_blt">
								bv_blt()</a></span> call.&nbsp; It also avoids 
								the associated mapping and unmapping overhead if 
								a given implementation is never used.<br />
								<br />
								<em>As mentioned above, the CPU implementations 
								have (almost) no overhead associated with 
								mapping and unmapping, so they are a good choice 
								to use for the call to <span class="inline_code">

								<a href="#bv_map">bv_map()</a></span>.<br />
								</em></td>
				</tr>
				<tr>
								<td valign="top">c.&nbsp;</td>
								<td>If the client wants direct control over the 
								mapping and unmapping overhead, it can call the
								<span class="inline_code"><a href="#bv_map">
								bv_map()</a></span> function of each 
								implementation, as indicated above.&nbsp; Each 
								implementation will perform the mapping at that 
								time, so that the overhead will not appear on 
								subsequent calls to <span class="inline_code">

								<a href="#bv_blt">bv_blt()</a></span>.&nbsp;</td>
				</tr>
</table>
<p>4.&nbsp; Next the client must create <span class="inline_code">
<a href="#bvsurfgeom">bvsurfgeom</a></span> objects for each way in which a 
buffer will be accessed.&nbsp; Often, there is only one way in which a buffer is 
accessed, so there will be the same number of buffers, <span class="inline_code">

<a href="#bvbuffdesc">bvbuffdesc</a></span>, and <span class="inline_code">
<a href="#bvsurfgeom">bvsurfgeom</a></span> objects.&nbsp; If that&#39;s the case, 
it may be convenient for the client to combine them into a parent structure.&nbsp; 
It may even be possible to share a single bvbuffgeom structure among buffers.&nbsp; 
Or there will be times when it is necessary to treat a buffer in different ways 
for different BLTs.&nbsp; Having these two structures separated allows all of 
these combinations.</p>
<table class="indent1">

				<tr>
								<td valign="top">
								<p class="small_code_block_in_table">struct bvsurfgeom 
								geom =<br />

&nbsp; {sizeof(struct bvsurfgeom), 0};<br />
								<br />
								geom.format = OCDFMT_RGB24;<br />
								geom.width = width;<br />
								geom.height = height;<br />
								geom.virtstride = stride;</p>

								</td>
								<td style="width: 30px" class="center">or</td>
								<td valign="top">
								<p class="inline_code">
								<span class="small_code_block_in_table">struct 
								bvsurfgeom geom;<br />
								<br />
								memset(&amp;geom, 0, sizeof(geom));<br />

								geom.structsize = sizeof(geom);<br />
								geom.width = width;<br />
								geom.height = height;<br />
								geom.virtstride = stride;</span></p>
								</td>
				</tr>
</table>

<p class="strong_emphasis">Note that the client must ensure that any additional members 
in <span class="inline_code"><a href="#bvsurfgeom">bvsurfgeom</a></span> are 
initialized to 0 for future compatibility.</p>

<p>5. &nbsp;Now the client is ready to fill in a bvbltparams structure to specify the 
type of BLT requested.&nbsp; Here is an example of a simple copy from the lower 
right corner of a surface to the upper left:</p>

<p class="small_code_block">struct bvbltparams bltparams = {sizeof(struct 
bvbltparams), 0};<br />
<br />
bltparams.flags = BVFLAG_ROP;<br />
bltparams.rop = 0xCCCC; /* SRCCOPY */<br />
bltparams.dstdesc = &amp;buff;<br />
bltparams.dstgeom = &amp;geom;<br />

bltparams.dstrect.left = 0;<br />
bltparams.dstrect.top = 0;<br />
bltparams.dstwidth = width / 2;<br />
bltparams.dstheight = height / 2;<br />
bltparams.src1.desc = &amp;buff;<br />
bltparams.src1geom = &amp;geom;<br />
bltparams.src1rect.left = width / 2;<br />
bltparams.src1rect.top = height / 2;<br />

bltparams.src1rect.width = width / 2;<br />
bltparams.src1rect.height = height / 2;</p>
<p>6.&nbsp; And next the client can trigger the BLT by calling
<span class="inline_code"><a href="#bv_blt">bv_blt()</a></span>:</p>
<p class="small_code_block">bv_blt(&amp;bltparams);&nbsp;</p>
<p><em>If the client cannot complete the requested BLT, it returns a </em>
<span class="inline_code"><a href="#bverror"><em>bverror</em></a></span><em> 

indicating the issue.&nbsp;</em></p>
<p>7.&nbsp; Finally, the client should clean up:</p>
<p class="small_code_block">bv_unmap(&amp;buff);&nbsp;</p>

</body>

</html>
